// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
import "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol";

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {SuperTokenB} from "./SuperTokenB.sol";

contract BridgeB is Ownable {
    /**
     * @notice  we have no plan to change token.
     * In real life should be list of supported tokens that updated
     */
    address public immutable superTokenB;

    /**
     * @notice  address of bridge to make signature
     */
    address public relayerAddress;

    /**
     * @notice  we are going to work with crypto
     */
    using ECDSA for bytes32;
    using MessageHashUtils for bytes32;

    /**
     * @notice track used nonces
     */
    mapping(uint256 => bool) private _usedNonces;

    /**
     * @dev Receive token event
     * @param nonce A unique, sequential ID for the transaction.
     * @param recipient The recipient address
     * @param amount The amount of tokens locked.
     */
    event TokensClaimed(
        uint256 indexed nonce,
        address indexed recipient,
        uint256 indexed amount
    );

    constructor(address superTokenBAddress) Ownable(msg.sender) {
        require(
            superTokenBAddress != address(0),
            "Token address cannot be zero"
        );

        superTokenB = superTokenBAddress;
    }

    /**
     * @notice Allows a user to claim tokens by providing a valid signature from the user/bridge
     * @param recipient The address that will receive the tokens.
     * @param amount The amount of tokens to be minted.
     * @param nonce A unique number to prevent replay attacks.
     * @param signature The signature generated by the off-chain signer.
     */
    function releaseTokens(
        address recipient,
        uint256 amount,
        uint256 nonce,
        bytes memory signature
    ) public {
        require(!_usedNonces[nonce], "Bridge: Nonce has already been used.");
        bytes32 messageHash = getMessageHash(recipient, amount, nonce);
        address recoveredSigner = messageHash.toEthSignedMessageHash().recover(
            signature
        );
        require(recoveredSigner == relayerAddress, "Bridge: Invalid signature.");
        require(
            recoveredSigner != address(0),
            "Bridge: ECDSA recovery failed."
        );
        _usedNonces[nonce] = true;

        SuperTokenB(superTokenB).mint(recipient, amount);

        emit TokensClaimed(nonce, recipient, amount);
    }

    /**
     * @dev Creates the hash of the message to be signed.
     * This function should be consistent with the off-chain signing logic.
     * Better to keep it separated for better test coverage
     */
    function getMessageHash(
        address recipient,
        uint256 amount,
        uint256 nonce
    ) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(recipient, amount, nonce));
    }

    /**
     * @dev Allows the owner to update the bridge address in case the key is compromised.
     */
    function updateRelayerAddress(address _newSigner) public onlyOwner {
        relayerAddress = _newSigner;
    }
}
